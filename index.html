<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPERATION OVERLORD - 3D TACTICAL WARFARE</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        @import url('https://fonts.googleapis.com/css2?family=Special+Elite&display=swap');

        body {
            background: linear-gradient(135deg, #3e2723 0%, #4e342e 50%, #5d4037 100%);
            font-family: 'Courier New', 'Special Elite', monospace;
            color: #3e2723;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,.03) 2px, rgba(0,0,0,.03) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,0,0,.03) 2px, rgba(0,0,0,.03) 4px);
            pointer-events: none;
            z-index: 1;
        }

        /* スタート画面 */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background: linear-gradient(135deg, #3e2723 0%, #4e342e 50%, #5d4037 100%);
        }

        #startContent {
            background: linear-gradient(135deg, #d7ccc8 0%, #bcaaa4 100%);
            padding: 50px;
            border-radius: 5px;
            border: 8px solid #4e342e;
            box-shadow: 
                0 0 0 3px #d7ccc8,
                0 20px 60px rgba(0,0,0,0.5),
                inset 0 0 50px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 600px;
            position: relative;
            z-index: 2;
        }

        #startContent::before {
            content: '★';
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #bf360c;
        }

        #startContent h1 {
            font-size: 42px;
            color: #bf360c;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
            letter-spacing: 4px;
            font-weight: bold;
            text-transform: uppercase;
        }

        #startContent .subtitle {
            color: #5d4037;
            font-size: 16px;
            margin-bottom: 10px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        #startContent .year {
            font-size: 64px;
            color: #3e2723;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 3px 3px 0px rgba(191, 54, 12, 0.3);
        }

        .difficulty-select {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 30px 0;
        }

        .difficulty-option {
            background: linear-gradient(135deg, #efebe9 0%, #d7ccc8 100%);
            padding: 20px;
            border: 4px solid #6d4c41;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .difficulty-option::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            border: 1px solid rgba(109, 76, 65, 0.3);
            pointer-events: none;
        }

        .difficulty-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            border-color: #bf360c;
        }

        .difficulty-option.selected {
            border-color: #bf360c;
            background: linear-gradient(135deg, #ffccbc 0%, #ffab91 100%);
            box-shadow: 0 8px 16px rgba(191, 54, 12, 0.4);
        }

        .difficulty-name {
            font-size: 24px;
            font-weight: bold;
            color: #3e2723;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .difficulty-desc {
            font-size: 14px;
            color: #5d4037;
        }

        /* ゲーム画面 */
        #gameCanvas {
            display: block;
            cursor: grab;
        }

        #gameCanvas.dragging {
            cursor: grabbing;
        }

        #gameContainer {
            display: none;
        }

        #gameContainer.active {
            display: block;
        }

        #ui-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 340px;
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: none;
            z-index: 100;
        }

        #ui-overlay > * {
            pointer-events: auto;
        }

        #ui-overlay::-webkit-scrollbar {
            width: 10px;
        }

        #ui-overlay::-webkit-scrollbar-track {
            background: #3e2723;
        }

        #ui-overlay::-webkit-scrollbar-thumb {
            background: #6d4c41;
            border: 2px solid #3e2723;
        }

        .panel {
            background: linear-gradient(135deg, #d7ccc8 0%, #bcaaa4 100%);
            padding: 15px;
            border: 5px solid #4e342e;
            box-shadow: 
                0 0 0 2px #d7ccc8,
                0 8px 24px rgba(0,0,0,0.6),
                inset 0 0 30px rgba(0,0,0,0.05);
            position: relative;
            margin-bottom: 15px;
        }

        .panel::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            border: 1px solid rgba(109, 76, 65, 0.2);
            pointer-events: none;
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            color: #bf360c;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 3px double #4e342e;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #turnStatus {
            text-align: center;
            padding: 18px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #81c784 0%, #66bb6a 100%);
            border: 4px solid #2e7d32;
            box-shadow: 0 6px 20px rgba(46, 125, 50, 0.4);
            color: #1b5e20;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
        }

        #turnStatus::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        #turnStatus.enemy-turn {
            background: linear-gradient(135deg, #e57373 0%, #ef5350 100%);
            border-color: #c62828;
            box-shadow: 0 6px 20px rgba(198, 40, 40, 0.4);
            color: #b71c1c;
        }

        .unit-card {
            background: linear-gradient(135deg, #efebe9 0%, #d7ccc8 100%);
            padding: 10px;
            margin: 8px 0;
            border: 3px solid #6d4c41;
            transition: all 0.3s;
            font-size: 13px;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
            position: relative;
            cursor: pointer;
        }

        .unit-card::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border: 1px solid rgba(109, 76, 65, 0.2);
            pointer-events: none;
        }

        .unit-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(109, 76, 65, 0.4);
        }

        .unit-card.selected {
            border-color: #bf360c;
            background: linear-gradient(135deg, #ffccbc 0%, #ffab91 100%);
            box-shadow: 0 5px 20px rgba(191, 54, 12, 0.5);
        }

        .unit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .unit-name {
            font-weight: bold;
            font-size: 14px;
            color: #3e2723;
        }

        .hp-bar-container {
            background: #3e2723;
            height: 10px;
            border: 2px solid #4e342e;
            overflow: hidden;
            margin: 6px 0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #689f38 0%, #7cb342 100%);
            transition: width 0.3s, background 0.3s;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }

        .hp-bar.low {
            background: linear-gradient(90deg, #d32f2f 0%, #e53935 100%);
        }

        .unit-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            font-size: 11px;
            color: #3e2723;
            margin-top: 6px;
        }

        .stat {
            background: rgba(62, 39, 35, 0.1);
            padding: 3px 6px;
            border: 1px solid #6d4c41;
        }

        .stat-label {
            color: #5d4037;
            font-weight: bold;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            font-size: 10px;
            font-weight: bold;
            border: 2px solid;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-badge.ready {
            background: #81c784;
            color: #1b5e20;
            border-color: #2e7d32;
        }

        .status-badge.done {
            background: #bdbdbd;
            color: #424242;
            border-color: #616161;
        }

        .status-badge.veteran {
            background: #ffd54f;
            color: #f57f17;
            border-color: #f9a825;
        }

        button {
            background: linear-gradient(135deg, #6d4c41 0%, #5d4037 100%);
            color: #efebe9;
            border: 4px solid #3e2723;
            padding: 16px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            font-family: 'Courier New', monospace;
            position: relative;
            width: 100%;
            margin: 5px 0;
        }

        button::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border: 1px solid rgba(239, 235, 233, 0.2);
            pointer-events: none;
        }

        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
            background: linear-gradient(135deg, #5d4037 0%, #4e342e 100%);
        }

        button:disabled {
            background: linear-gradient(135deg, #8d6e63 0%, #795548 100%);
            cursor: not-allowed;
            opacity: 0.6;
        }

        button.success {
            background: linear-gradient(135deg, #558b2f 0%, #689f38 100%);
            border-color: #33691e;
        }

        button.success:hover:not(:disabled) {
            background: linear-gradient(135deg, #689f38 0%, #7cb342 100%);
        }

        button.secondary {
            background: linear-gradient(135deg, #bf360c 0%, #d84315 100%);
            border-color: #3e2723;
        }

        button.secondary:hover:not(:disabled) {
            background: linear-gradient(135deg, #d84315 0%, #bf360c 100%);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(62, 39, 35, 0.1);
            border: 2px solid #6d4c41;
            margin: 6px 0;
            font-size: 12px;
            color: #3e2723;
        }

        .terrain-legend {
            width: 24px;
            height: 24px;
            border: 2px solid #3e2723;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        #instructions {
            background: linear-gradient(135deg, #d7ccc8 0%, #bcaaa4 100%);
            padding: 15px;
            border: 5px solid #4e342e;
            box-shadow: 0 0 0 2px #d7ccc8, 0 8px 24px rgba(0,0,0,0.6);
            position: fixed;
            bottom: 20px;
            left: 20px;
            max-width: 300px;
            font-size: 12px;
            color: #3e2723;
            z-index: 100;
        }

        #instructions strong {
            color: #bf360c;
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .info-badge {
            display: inline-block;
            background: rgba(191, 54, 12, 0.2);
            padding: 6px 12px;
            border: 2px solid #bf360c;
            font-size: 12px;
            margin: 8px 5px 5px 0;
            font-weight: bold;
            color: #3e2723;
        }

        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(62, 39, 35, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #gameOverContent {
            background: linear-gradient(135deg, #d7ccc8 0%, #bcaaa4 100%);
            padding: 60px;
            border: 10px solid #4e342e;
            text-align: center;
            box-shadow: 0 0 0 3px #d7ccc8, 0 20px 60px rgba(0,0,0,0.8);
            position: relative;
        }

        #gameOverContent::before {
            content: '★ ★ ★';
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #bf360c;
            letter-spacing: 20px;
        }

        #gameOverContent.win {
            border-color: #2e7d32;
        }

        #gameOverText {
            font-size: 48px;
            margin-bottom: 20px;
            color: #3e2723;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        #scoreDisplay {
            font-size: 18px;
            color: #5d4037;
            margin-bottom: 30px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- スタート画面 -->
    <div id="startScreen">
        <div id="startContent">
            <h1>OPERATION OVERLORD</h1>
            <div class="subtitle">3D TACTICAL WARFARE</div>
            <div class="year">1944</div>

            <div class="difficulty-select">
                <div class="difficulty-option selected" data-difficulty="easy">
                    <div class="difficulty-name">★ PRIVATE</div>
                    <div class="difficulty-desc">ノルマンディー上陸作戦 | 敵6体 vs 味方8体 | 初級兵士</div>
                </div>
                <div class="difficulty-option" data-difficulty="normal">
                    <div class="difficulty-name">★★ SERGEANT</div>
                    <div class="difficulty-desc">東部戦線 | 敵8体 vs 味方9体 | 熟練兵士</div>
                </div>
                <div class="difficulty-option" data-difficulty="hard">
                    <div class="difficulty-name">★★★ CAPTAIN</div>
                    <div class="difficulty-desc">アルデンヌの戦い | 敵10体 vs 味方10体 | 精鋭部隊</div>
                </div>
            </div>

            <button class="success" onclick="startGame()" style="font-size: 20px; padding: 20px;">DEPLOY FORCES</button>
        </div>
    </div>

    <!-- ゲーム画面 -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-overlay">
            <div class="panel">
                <div id="turnStatus">ALLIED TURN</div>
                <div id="difficultyBadge" class="info-badge"></div>
            </div>

            <div class="panel">
                <div class="panel-title">ALLIED FORCES</div>
                <div id="unitsDisplay"></div>
            </div>

            <div class="panel">
                <div class="panel-title">TERRAIN INTEL</div>
                <div class="legend-item">
                    <div class="terrain-legend" style="background: #c5e1a5;"></div>
                    <span>平地 (移動1)</span>
                </div>
                <div class="legend-item">
                    <div class="terrain-legend" style="background: #558b2f;"></div>
                    <span>森林 (移動2, 防御+30%)</span>
                </div>
                <div class="legend-item">
                    <div class="terrain-legend" style="background: #8d6e63;"></div>
                    <span>山岳 (移動3, 防御+50%)</span>
                </div>
                <div class="legend-item">
                    <div class="terrain-legend" style="background: #64b5f6;"></div>
                    <span>河川 (移動4, 防御+20%)</span>
                </div>
                <div class="legend-item">
                    <div class="terrain-legend" style="background: #ffe082;"></div>
                    <span>砂浜 (移動2, 防御-10%)</span>
                </div>
            </div>

            <div class="panel">
                <button id="endTurnBtn" class="success" onclick="endPlayerTurn()">END TURN</button>
                <button class="secondary" onclick="resetCamera()">RESET CAMERA</button>
                <button class="secondary" onclick="backToMenu()">RETREAT</button>
            </div>
        </div>

        <div id="instructions">
            <strong>操作方法:</strong>
            • 左ドラッグ: カメラ回転<br>
            • 左クリック: 駒選択・移動・攻撃<br>
            • ホイール: ズーム<br>
            <br>
            <strong>色分け:</strong>
            濃い茶色 = 味方<br>
            灰色 = 敵
        </div>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="gameOverlay">
        <div id="gameOverContent">
            <div id="gameOverText">VICTORY!</div>
            <div id="scoreDisplay"></div>
            <button class="success" onclick="restartGame()" style="font-size: 18px; padding: 20px 40px; margin-right: 10px;">REDEPLOY</button>
            <button class="secondary" onclick="backToMenu()" style="font-size: 18px; padding: 20px 40px;">HEADQUARTERS</button>
        </div>
    </div>

    <script>
        // Three.js セットアップ
        let scene, camera, renderer, raycaster, mouse;
        let terrainMeshes = [];
        let unitMeshes = new Map();
        let unitHpBars = new Map();
        let selectedUnitMesh = null;
        let moveIndicators = [];
        let attackIndicators = [];

        const GRID_SIZE = 10;
        const TILE_SIZE = 2;
        const TILE_HEIGHT = 0.5;

        const TERRAIN = {
            PLAIN: { name: '平地', height: 0, color: 0xc5e1a5, moveCost: 1, defense: 0 },
            FOREST: { name: '森林', height: 0.3, color: 0x558b2f, moveCost: 2, defense: 0.3 },
            MOUNTAIN: { name: '山岳', height: 0.8, color: 0x8d6e63, moveCost: 3, defense: 0.5 },
            RIVER: { name: '河川', height: -0.1, color: 0x64b5f6, moveCost: 4, defense: 0.2 },
            BEACH: { name: '砂浜', height: 0, color: 0xffe082, moveCost: 2, defense: -0.1 }
        };

        let selectedDifficulty = 'easy';
        let gameState = {
            turn: 'player',
            selectedUnit: null,
            playerUnits: [],
            enemyUnits: [],
            gameOver: false,
            turnCount: 1,
            terrain: [],
            difficulty: 'easy'
        };

        // 難易度選択
        document.querySelectorAll('.difficulty-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.difficulty-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
                selectedDifficulty = this.dataset.difficulty;
            });
        });

        class Unit {
            constructor(x, y, type, isPlayer) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.isPlayer = isPlayer;
                this.setupStats();
                this.hasMoved = false;
                this.hasAttacked = false;
                this.kills = 0;
                this.id = Math.random().toString(36).substr(2, 9);
            }

            setupStats() {
                const stats = {
                    'infantry': { hp: 100, move: 3, attackRange: 2, attack: 30, name: '歩兵' },
                    'tank': { hp: 180, move: 2, attackRange: 3, attack: 45, name: '戦車' },
                    'artillery': { hp: 120, move: 2, attackRange: 5, attack: 40, name: '砲兵' },
                    'sniper': { hp: 80, move: 2, attackRange: 6, attack: 60, name: '狙撃兵' },
                    'heavy_tank': { hp: 250, move: 2, attackRange: 3, attack: 55, name: '重戦車' },
                    'recon': { hp: 70, move: 4, attackRange: 2, attack: 20, name: '偵察兵' },
                    'medic': { hp: 90, move: 3, attackRange: 1, attack: 15, name: '衛生兵' },
                    'engineer': { hp: 85, move: 2, attackRange: 2, attack: 25, name: '工兵' }
                };

                const s = stats[this.type];
                this.hp = s.hp;
                this.maxHp = s.hp;
                this.moveRange = s.move;
                this.attackRange = s.attackRange;
                this.attackPower = s.attack;
                this.unitName = s.name;
            }

            getName() {
                const prefix = this.isPlayer ? '味方' : '敵';
                const suffix = this.kills >= 2 ? ' ★' : '';
                return prefix + this.unitName + suffix;
            }

            // 敵味方で色を変える - 味方をより濃い茶色に
            getColor() {
                if (this.isPlayer) {
                    // 味方は濃い茶色
                    return 0x5d4037; // ダークブラウン
                } else {
                    // 敵は灰色
                    return 0x616161; // ダークグレー
                }
            }

            reset() {
                this.hasMoved = false;
                this.hasAttacked = false;
            }
        }

        function startGame() {
            gameState.difficulty = selectedDifficulty;
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameContainer').classList.add('active');

            if (!scene) {
                init();
            } else {
                initGame();
            }
        }

        function backToMenu() {
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('gameOverlay').style.display = 'none';
            document.getElementById('startScreen').style.display = 'flex';
            clearIndicators();
            if (gameState.selectedUnit) {
                gameState.selectedUnit = null;
                selectedUnitMesh = null;
            }
        }

        function init() {
            // シーン
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x3e2723);
            scene.fog = new THREE.Fog(0x3e2723, 20, 50);

            // カメラ
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 15, 10);
            camera.lookAt(GRID_SIZE * TILE_SIZE / 2, 0, GRID_SIZE * TILE_SIZE / 2);

            // レンダラー
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // ライト
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // レイキャスター
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // イベント
            window.addEventListener('resize', onWindowResize);
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            // ゲーム初期化
            initGame();
            animate();
        }

        function initGame() {
            // 既存のメッシュをクリア
            terrainMeshes.forEach(mesh => scene.remove(mesh));
            unitMeshes.forEach(mesh => scene.remove(mesh));
            unitHpBars.forEach(bar => {
                scene.remove(bar.background);
                scene.remove(bar.foreground);
            });
            terrainMeshes = [];
            unitMeshes.clear();
            unitHpBars.clear();
            clearIndicators();

            // 地形生成
            gameState.terrain = generateTerrain(gameState.difficulty);
            createTerrainMeshes();

            // ユニット配置
            const playerSetup = {
                'easy': [
                    new Unit(0, 9, 'infantry', true),
                    new Unit(2, 8, 'tank', true),
                    new Unit(4, 9, 'heavy_tank', true),
                    new Unit(6, 8, 'artillery', true),
                    new Unit(8, 9, 'sniper', true),
                    new Unit(1, 9, 'recon', true),
                    new Unit(7, 9, 'engineer', true),
                    new Unit(5, 8, 'infantry', true)
                ],
                'normal': [
                    new Unit(0, 9, 'infantry', true),
                    new Unit(2, 8, 'tank', true),
                    new Unit(4, 9, 'heavy_tank', true),
                    new Unit(6, 8, 'artillery', true),
                    new Unit(8, 9, 'sniper', true),
                    new Unit(1, 9, 'recon', true),
                    new Unit(7, 9, 'engineer', true),
                    new Unit(5, 8, 'medic', true),
                    new Unit(3, 9, 'infantry', true)
                ],
                'hard': [
                    new Unit(0, 9, 'infantry', true),
                    new Unit(2, 8, 'heavy_tank', true),
                    new Unit(4, 9, 'heavy_tank', true),
                    new Unit(6, 8, 'artillery', true),
                    new Unit(8, 9, 'sniper', true),
                    new Unit(1, 9, 'recon', true),
                    new Unit(7, 9, 'tank', true),
                    new Unit(5, 8, 'medic', true),
                    new Unit(3, 9, 'infantry', true),
                    new Unit(9, 8, 'engineer', true)
                ]
            };

            const enemySetup = {
                'easy': [
                    new Unit(1, 0, 'infantry', false),
                    new Unit(3, 1, 'tank', false),
                    new Unit(5, 0, 'artillery', false),
                    new Unit(7, 1, 'sniper', false),
                    new Unit(9, 0, 'recon', false),
                    new Unit(4, 1, 'infantry', false)
                ],
                'normal': [
                    new Unit(1, 0, 'infantry', false),
                    new Unit(3, 1, 'heavy_tank', false),
                    new Unit(5, 0, 'artillery', false),
                    new Unit(7, 1, 'tank', false),
                    new Unit(9, 0, 'sniper', false),
                    new Unit(0, 1, 'recon', false),
                    new Unit(6, 0, 'infantry', false),
                    new Unit(2, 0, 'engineer', false)
                ],
                'hard': [
                    new Unit(1, 0, 'infantry', false),
                    new Unit(3, 1, 'heavy_tank', false),
                    new Unit(5, 0, 'artillery', false),
                    new Unit(7, 1, 'tank', false),
                    new Unit(9, 0, 'sniper', false),
                    new Unit(0, 1, 'recon', false),
                    new Unit(6, 0, 'infantry', false),
                    new Unit(2, 0, 'heavy_tank', false),
                    new Unit(8, 1, 'artillery', false),
                    new Unit(4, 0, 'sniper', false)
                ]
            };

            gameState.playerUnits = playerSetup[gameState.difficulty];
            gameState.enemyUnits = enemySetup[gameState.difficulty];

            createUnitMeshes();

            gameState.turn = 'player';
            gameState.selectedUnit = null;
            gameState.gameOver = false;
            gameState.turnCount = 1;

            const difficultyNames = {
                'easy': '★ PRIVATE - ノルマンディー',
                'normal': '★★ SERGEANT - 東部戦線',
                'hard': '★★★ CAPTAIN - アルデンヌ'
            };
            document.getElementById('difficultyBadge').textContent = difficultyNames[gameState.difficulty];

            updateUI();
        }

        function generateTerrain(difficulty) {
            const terrain = [];

            if (difficulty === 'easy') {
                for (let y = 0; y < GRID_SIZE; y++) {
                    terrain[y] = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (y <= 1) {
                            terrain[y][x] = TERRAIN.BEACH;
                        } else if (y >= 7) {
                            terrain[y][x] = Math.random() < 0.7 ? TERRAIN.PLAIN : TERRAIN.FOREST;
                        } else if (y <= 3) {
                            terrain[y][x] = Math.random() < 0.6 ? TERRAIN.MOUNTAIN : TERRAIN.FOREST;
                        } else {
                            const rand = Math.random();
                            if (rand < 0.5) terrain[y][x] = TERRAIN.PLAIN;
                            else if (rand < 0.8) terrain[y][x] = TERRAIN.FOREST;
                            else terrain[y][x] = TERRAIN.MOUNTAIN;
                        }
                    }
                }
            } else if (difficulty === 'normal') {
                for (let y = 0; y < GRID_SIZE; y++) {
                    terrain[y] = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (Math.abs(x - y) <= 1 && x >= 3 && x <= 6) {
                            terrain[y][x] = TERRAIN.RIVER;
                        } else {
                            const rand = Math.random();
                            if (rand < 0.6) terrain[y][x] = TERRAIN.PLAIN;
                            else if (rand < 0.85) terrain[y][x] = TERRAIN.FOREST;
                            else terrain[y][x] = TERRAIN.MOUNTAIN;
                        }
                    }
                }
            } else {
                for (let y = 0; y < GRID_SIZE; y++) {
                    terrain[y] = [];
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const rand = Math.random();
                        if (rand < 0.3) terrain[y][x] = TERRAIN.PLAIN;
                        else if (rand < 0.75) terrain[y][x] = TERRAIN.FOREST;
                        else if (rand < 0.9) terrain[y][x] = TERRAIN.MOUNTAIN;
                        else terrain[y][x] = TERRAIN.RIVER;
                    }
                }
            }

            return terrain;
        }

        function createTerrainMeshes() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const terrain = gameState.terrain[y][x];
                    const height = TILE_HEIGHT + terrain.height;

                    const geometry = new THREE.BoxGeometry(TILE_SIZE * 0.95, height, TILE_SIZE * 0.95);
                    const material = new THREE.MeshLambertMaterial({ color: terrain.color });
                    const mesh = new THREE.Mesh(geometry, material);

                    mesh.position.set(
                        x * TILE_SIZE,
                        height / 2,
                        y * TILE_SIZE
                    );
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = { type: 'terrain', x, y };

                    scene.add(mesh);
                    terrainMeshes.push(mesh);
                }
            }
        }

        function createUnitMeshes() {
            const allUnits = [...gameState.playerUnits, ...gameState.enemyUnits];

            allUnits.forEach(unit => {
                const terrain = gameState.terrain[unit.y][unit.x];
                const baseHeight = TILE_HEIGHT + terrain.height;
                const unitColor = unit.getColor(); // 敵味方で色分け

                let mesh;
                if (unit.type === 'tank' || unit.type === 'heavy_tank') {
                    const group = new THREE.Group();

                    const bodyGeo = new THREE.BoxGeometry(1.2, 0.4, 1.5);
                    const bodyMat = new THREE.MeshLambertMaterial({ color: unitColor });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    body.position.y = 0.2;
                    body.castShadow = true;
                    group.add(body);

                    const turretGeo = new THREE.BoxGeometry(0.8, 0.3, 0.8);
                    const turret = new THREE.Mesh(turretGeo, bodyMat);
                    turret.position.y = 0.55;
                    turret.castShadow = true;
                    group.add(turret);

                    const barrelGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
                    const barrel = new THREE.Mesh(barrelGeo, bodyMat);
                    barrel.rotation.z = Math.PI / 2;
                    barrel.position.set(0.5, 0.55, 0);
                    barrel.castShadow = true;
                    group.add(barrel);

                    if (unit.type === 'heavy_tank') {
                        const armorGeo = new THREE.BoxGeometry(1.4, 0.15, 1.7);
                        const armor = new THREE.Mesh(armorGeo, bodyMat);
                        armor.position.y = 0.95;
                        armor.castShadow = true;
                        group.add(armor);
                    }

                    group.userData = { type: 'unit', unit: unit };
                    mesh = group;
                } else if (unit.type === 'artillery') {
                    const group = new THREE.Group();

                    const baseGeo = new THREE.CylinderGeometry(0.4, 0.5, 0.3, 8);
                    const baseMat = new THREE.MeshLambertMaterial({ color: unitColor });
                    const base = new THREE.Mesh(baseGeo, baseMat);
                    base.castShadow = true;
                    group.add(base);

                    const barrelGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
                    const barrel = new THREE.Mesh(barrelGeo, baseMat);
                    barrel.rotation.z = -Math.PI / 3;
                    barrel.position.set(0, 0.5, 0);
                    barrel.castShadow = true;
                    group.add(barrel);

                    group.userData = { type: 'unit', unit: unit };
                    mesh = group;
                } else {
                    const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                    const material = new THREE.MeshLambertMaterial({ color: unitColor });
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.userData = { type: 'unit', unit: unit };
                }

                mesh.position.set(
                    unit.x * TILE_SIZE,
                    baseHeight + 0.5,
                    unit.y * TILE_SIZE
                );

                scene.add(mesh);
                unitMeshes.set(unit.id, mesh);

                // HPバー作成
                createHpBar(unit);
            });
        }

        function createHpBar(unit) {
            const hpBarWidth = 1.2;
            const hpBarHeight = 0.15;
            const hpBarY = 1.5;

            // 背景（黒）
            const bgGeo = new THREE.PlaneGeometry(hpBarWidth, hpBarHeight);
            const bgMat = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeo, bgMat);
            bgMesh.position.set(
                unit.x * TILE_SIZE,
                hpBarY,
                unit.y * TILE_SIZE
            );

            // 前景（HP）
            const fgGeo = new THREE.PlaneGeometry(hpBarWidth, hpBarHeight);
            const hpPercent = unit.hp / unit.maxHp;
            let color;
            if (hpPercent > 0.6) {
                color = 0x7cb342; // 緑
            } else if (hpPercent > 0.3) {
                color = 0xfdd835; // 黄色
            } else {
                color = 0xe53935; // 赤
            }
            const fgMat = new THREE.MeshBasicMaterial({ 
                color: color,
                side: THREE.DoubleSide
            });
            const fgMesh = new THREE.Mesh(fgGeo, fgMat);
            fgMesh.position.set(
                unit.x * TILE_SIZE,
                hpBarY + 0.01,
                unit.y * TILE_SIZE
            );
            fgMesh.scale.x = hpPercent;

            scene.add(bgMesh);
            scene.add(fgMesh);

            unitHpBars.set(unit.id, {
                background: bgMesh,
                foreground: fgMesh,
                unit: unit
            });
        }

        function updateHpBar(unit) {
            const hpBar = unitHpBars.get(unit.id);
            if (!hpBar) return;

            const hpPercent = unit.hp / unit.maxHp;
            hpBar.foreground.scale.x = hpPercent;

            // 色を変更
            let color;
            if (hpPercent > 0.6) {
                color = 0x7cb342;
            } else if (hpPercent > 0.3) {
                color = 0xfdd835;
            } else {
                color = 0xe53935;
            }
            hpBar.foreground.material.color.setHex(color);
        }

        function updateHpBarPosition(unit) {
            const hpBar = unitHpBars.get(unit.id);
            if (!hpBar) return;

            const hpBarY = 1.5;
            hpBar.background.position.set(
                unit.x * TILE_SIZE,
                hpBarY,
                unit.y * TILE_SIZE
            );
            hpBar.foreground.position.set(
                unit.x * TILE_SIZE,
                hpBarY + 0.01,
                unit.y * TILE_SIZE
            );
        }

        function clearIndicators() {
            moveIndicators.forEach(mesh => scene.remove(mesh));
            attackIndicators.forEach(mesh => scene.remove(mesh));
            moveIndicators = [];
            attackIndicators = [];
        }

        function showMoveRange(unit) {
            const visited = new Set();
            const queue = [{x: unit.x, y: unit.y, cost: 0}];

            while (queue.length > 0) {
                const {x, y, cost} = queue.shift();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x !== unit.x || y !== unit.y) {
                    if (!getUnitAt(x, y)) {
                        const terrain = gameState.terrain[y][x];
                        const height = TILE_HEIGHT + terrain.height;

                        const geo = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
                        const mat = new THREE.MeshBasicMaterial({ 
                            color: 0x81c784, 
                            transparent: true, 
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        });
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.rotation.x = -Math.PI / 2;
                        mesh.position.set(x * TILE_SIZE, height + 0.05, y * TILE_SIZE);
                        mesh.userData = { type: 'moveIndicator', x, y };
                        scene.add(mesh);
                        moveIndicators.push(mesh);
                    }
                }

                const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (isValidPosition(nx, ny) && !visited.has(`${nx},${ny}`)) {
                        const terrain = gameState.terrain[ny][nx];
                        const newCost = cost + terrain.moveCost;
                        if (newCost <= unit.moveRange) {
                            queue.push({x: nx, y: ny, cost: newCost});
                        }
                    }
                }
            }
        }

        function showAttackRange(unit) {
            for (let dx = -unit.attackRange; dx <= unit.attackRange; dx++) {
                for (let dy = -unit.attackRange; dy <= unit.attackRange; dy++) {
                    const dist = Math.abs(dx) + Math.abs(dy);
                    if (dist > 0 && dist <= unit.attackRange) {
                        const newX = unit.x + dx;
                        const newY = unit.y + dy;
                        if (isValidPosition(newX, newY)) {
                            const targetUnit = getUnitAt(newX, newY);
                            if (targetUnit && targetUnit.isPlayer !== unit.isPlayer) {
                                const terrain = gameState.terrain[newY][newX];
                                const height = TILE_HEIGHT + terrain.height;

                                const geo = new THREE.PlaneGeometry(TILE_SIZE * 0.9, TILE_SIZE * 0.9);
                                const mat = new THREE.MeshBasicMaterial({ 
                                    color: 0xe57373, 
                                    transparent: true, 
                                    opacity: 0.6,
                                    side: THREE.DoubleSide
                                });
                                const mesh = new THREE.Mesh(geo, mat);
                                mesh.rotation.x = -Math.PI / 2;
                                mesh.position.set(newX * TILE_SIZE, height + 0.06, newY * TILE_SIZE);
                                mesh.userData = { type: 'attackIndicator', targetUnit: targetUnit };
                                scene.add(mesh);
                                attackIndicators.push(mesh);
                            }
                        }
                    }
                }
            }
        }

        function updateUnitMeshPosition(unit) {
            const mesh = unitMeshes.get(unit.id);
            if (mesh) {
                const terrain = gameState.terrain[unit.y][unit.x];
                const baseHeight = TILE_HEIGHT + terrain.height;
                mesh.position.set(
                    unit.x * TILE_SIZE,
                    baseHeight + 0.5,
                    unit.y * TILE_SIZE
                );
                updateHpBarPosition(unit);
            }
        }

        function removeUnitMesh(unit) {
            const mesh = unitMeshes.get(unit.id);
            if (mesh) {
                scene.remove(mesh);
                unitMeshes.delete(unit.id);
            }

            const hpBar = unitHpBars.get(unit.id);
            if (hpBar) {
                scene.remove(hpBar.background);
                scene.remove(hpBar.foreground);
                unitHpBars.delete(unit.id);
            }
        }

        // マウスイベント
        let isDragging = false;
        let hasDragged = false;
        let mouseDownPos = { x: 0, y: 0 };
        let previousMousePosition = { x: 0, y: 0 };
        const DRAG_THRESHOLD = 5;

        function onMouseDown(event) {
            if (event.button === 0) {
                isDragging = true;
                hasDragged = false;
                mouseDownPos = { x: event.clientX, y: event.clientY };
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                const dragDistance = Math.sqrt(
                    Math.pow(event.clientX - mouseDownPos.x, 2) + 
                    Math.pow(event.clientY - mouseDownPos.y, 2)
                );

                if (dragDistance > DRAG_THRESHOLD) {
                    hasDragged = true;
                    document.getElementById('gameCanvas').classList.add('dragging');

                    const center = new THREE.Vector3(
                        GRID_SIZE * TILE_SIZE / 2, 
                        0, 
                        GRID_SIZE * TILE_SIZE / 2
                    );

                    const offset = new THREE.Vector3().subVectors(camera.position, center);
                    const spherical = new THREE.Spherical().setFromVector3(offset);

                    spherical.theta -= deltaX * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, spherical.phi - deltaY * 0.01));

                    offset.setFromSpherical(spherical);
                    camera.position.copy(center).add(offset);
                    camera.lookAt(center);
                }

                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                if (!hasDragged) {
                    handleClick(event);
                }
                isDragging = false;
                hasDragged = false;
                document.getElementById('gameCanvas').classList.remove('dragging');
            }
        }

        function onWheel(event) {
            event.preventDefault();
            const center = new THREE.Vector3(
                GRID_SIZE * TILE_SIZE / 2, 
                0, 
                GRID_SIZE * TILE_SIZE / 2
            );
            const direction = new THREE.Vector3().subVectors(camera.position, center).normalize();
            const distance = camera.position.distanceTo(center);
            const delta = event.deltaY > 0 ? 1 : -1;
            const newDistance = Math.max(10, Math.min(40, distance + delta));
            camera.position.copy(center).add(direction.multiplyScalar(newDistance));
        }

        function handleClick(event) {
            if (gameState.gameOver || gameState.turn !== 'player') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const allUnitMeshes = Array.from(unitMeshes.values());
            const unitIntersects = raycaster.intersectObjects(allUnitMeshes, true);

            if (unitIntersects.length > 0) {
                let clickedMesh = unitIntersects[0].object;
                while (clickedMesh && !clickedMesh.userData.unit) {
                    clickedMesh = clickedMesh.parent;
                }

                if (clickedMesh && clickedMesh.userData.unit) {
                    const unit = clickedMesh.userData.unit;

                    if (unit.isPlayer) {
                        gameState.selectedUnit = unit;
                        selectedUnitMesh = unitMeshes.get(unit.id);
                        clearIndicators();
                        if (!unit.hasMoved) showMoveRange(unit);
                        if (!unit.hasAttacked) showAttackRange(unit);
                        updateUI();
                    } else if (gameState.selectedUnit && !gameState.selectedUnit.hasAttacked) {
                        const dist = distance(gameState.selectedUnit.x, gameState.selectedUnit.y, unit.x, unit.y);
                        if (dist > 0 && dist <= gameState.selectedUnit.attackRange) {
                            attackUnit(gameState.selectedUnit, unit);
                        }
                    }
                }
                return;
            }

            if (attackIndicators.length > 0) {
                const attackIntersects = raycaster.intersectObjects(attackIndicators);
                if (attackIntersects.length > 0) {
                    const indicator = attackIntersects[0].object;
                    if (indicator.userData.targetUnit && gameState.selectedUnit) {
                        attackUnit(gameState.selectedUnit, indicator.userData.targetUnit);
                    }
                    return;
                }
            }

            if (moveIndicators.length > 0) {
                const moveIntersects = raycaster.intersectObjects(moveIndicators);
                if (moveIntersects.length > 0) {
                    const indicator = moveIntersects[0].object;
                    if (gameState.selectedUnit && !gameState.selectedUnit.hasMoved) {
                        gameState.selectedUnit.x = indicator.userData.x;
                        gameState.selectedUnit.y = indicator.userData.y;
                        gameState.selectedUnit.hasMoved = true;
                        updateUnitMeshPosition(gameState.selectedUnit);
                        clearIndicators();
                        if (!gameState.selectedUnit.hasAttacked) {
                            showAttackRange(gameState.selectedUnit);
                        }
                        updateUI();
                    }
                    return;
                }
            }

            const terrainIntersects = raycaster.intersectObjects(terrainMeshes);
            if (terrainIntersects.length > 0) {
                const clickedTerrain = terrainIntersects[0].object;
                const x = clickedTerrain.userData.x;
                const y = clickedTerrain.userData.y;

                if (gameState.selectedUnit && !gameState.selectedUnit.hasMoved) {
                    if (!getUnitAt(x, y) && canMoveTo(gameState.selectedUnit, x, y)) {
                        gameState.selectedUnit.x = x;
                        gameState.selectedUnit.y = y;
                        gameState.selectedUnit.hasMoved = true;
                        updateUnitMeshPosition(gameState.selectedUnit);
                        clearIndicators();
                        if (!gameState.selectedUnit.hasAttacked) {
                            showAttackRange(gameState.selectedUnit);
                        }
                        updateUI();
                    }
                }
            }
        }

        function resetCamera() {
            camera.position.set(10, 15, 10);
            camera.lookAt(GRID_SIZE * TILE_SIZE / 2, 0, GRID_SIZE * TILE_SIZE / 2);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 選択ユニットの浮遊アニメーション
            unitMeshes.forEach((mesh, id) => {
                if (gameState.selectedUnit && id === gameState.selectedUnit.id) {
                    const baseUnit = gameState.selectedUnit;
                    const terrain = gameState.terrain[baseUnit.y][baseUnit.x];
                    const baseHeight = TILE_HEIGHT + terrain.height + 0.5;
                    mesh.position.y = baseHeight + Math.sin(Date.now() * 0.005) * 0.15;
                }
            });

            // HPバーをカメラに向ける
            unitHpBars.forEach(hpBar => {
                hpBar.background.lookAt(camera.position);
                hpBar.foreground.lookAt(camera.position);
            });

            renderer.render(scene, camera);
        }

        // ゲームロジック
        function isValidPosition(x, y) {
            return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
        }

        function getUnitAt(x, y) {
            return [...gameState.playerUnits, ...gameState.enemyUnits].find(u => u.x === x && u.y === y);
        }

        function distance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        function canMoveTo(unit, targetX, targetY) {
            const visited = new Set();
            const queue = [{x: unit.x, y: unit.y, cost: 0}];

            while (queue.length > 0) {
                const {x, y, cost} = queue.shift();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (x === targetX && y === targetY) return true;

                const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
                for (const [dx, dy] of dirs) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (isValidPosition(nx, ny) && !visited.has(`${nx},${ny}`) && !getUnitAt(nx, ny)) {
                        const terrain = gameState.terrain[ny][nx];
                        const newCost = cost + terrain.moveCost;
                        if (newCost <= unit.moveRange) {
                            queue.push({x: nx, y: ny, cost: newCost});
                        }
                    }
                }
            }
            return false;
        }

        function attackUnit(attacker, target) {
            const terrain = gameState.terrain[target.y][target.x];
            const defenseBonus = terrain.defense;
            let actualDamage = Math.round(attacker.attackPower * (1 - defenseBonus));

            if (gameState.difficulty === 'hard' && !attacker.isPlayer) {
                actualDamage = Math.round(actualDamage * 1.2);
            }

            target.hp -= actualDamage;
            attacker.hasAttacked = true;

            // HPバー更新
            updateHpBar(target);

            if (target.hp <= 0) {
                const isEnemy = !target.isPlayer;
                const index = isEnemy ? gameState.enemyUnits.indexOf(target) : gameState.playerUnits.indexOf(target);
                const units = isEnemy ? gameState.enemyUnits : gameState.playerUnits;

                if (index > -1) {
                    units.splice(index, 1);
                    attacker.kills++;
                    removeUnitMesh(target);
                }

                if (gameState.enemyUnits.length === 0) {
                    endGame(true);
                } else if (gameState.playerUnits.length === 0) {
                    endGame(false);
                }
            }

            clearIndicators();
            updateUI();
        }

        function endPlayerTurn() {
            if (gameState.turn !== 'player' || gameState.gameOver) return;

            gameState.playerUnits.forEach(u => u.reset());
            gameState.selectedUnit = null;
            selectedUnitMesh = null;
            gameState.turn = 'enemy';
            gameState.turnCount++;
            clearIndicators();
            updateUI();

            document.getElementById('endTurnBtn').disabled = true;
            setTimeout(enemyTurn, 1000);
        }

        function enemyTurn() {
            if (gameState.gameOver) return;

            const smartAI = gameState.difficulty === 'hard';

            for (const enemy of gameState.enemyUnits) {
                let target = null;
                let minHp = Infinity;

                for (const player of gameState.playerUnits) {
                    const dist = distance(enemy.x, enemy.y, player.x, player.y);
                    if (dist > 0 && dist <= enemy.attackRange) {
                        if (smartAI) {
                            if (player.hp < minHp) {
                                minHp = player.hp;
                                target = player;
                            }
                        } else {
                            if (!target) target = player;
                        }
                    }
                }

                if (target) {
                    attackUnit(enemy, target);
                } else {
                    let nearestPlayer = null;
                    let nearestDist = Infinity;

                    for (const player of gameState.playerUnits) {
                        const dist = distance(enemy.x, enemy.y, player.x, player.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestPlayer = player;
                        }
                    }

                    if (nearestPlayer) {
                        const dirs = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
                        let bestMove = null;
                        let bestDist = distance(enemy.x, enemy.y, nearestPlayer.x, nearestPlayer.y);

                        for (const {dx, dy} of dirs) {
                            const newX = enemy.x + dx;
                            const newY = enemy.y + dy;

                            if (isValidPosition(newX, newY) && !getUnitAt(newX, newY)) {
                                const dist = distance(newX, newY, nearestPlayer.x, nearestPlayer.y);
                                if (dist < bestDist) {
                                    bestDist = dist;
                                    bestMove = {x: newX, y: newY};
                                }
                            }
                        }

                        if (bestMove) {
                            enemy.x = bestMove.x;
                            enemy.y = bestMove.y;
                            updateUnitMeshPosition(enemy);
                        }
                    }
                }
            }

            gameState.enemyUnits.forEach(u => u.reset());
            gameState.turn = 'player';
            document.getElementById('endTurnBtn').disabled = false;
            updateUI();
        }

        function updateUI() {
            const turnStatus = document.getElementById('turnStatus');

            if (gameState.turn === 'player') {
                turnStatus.textContent = `ALLIED TURN (${gameState.turnCount})`;
                turnStatus.classList.remove('enemy-turn');
            } else {
                turnStatus.textContent = 'AXIS TURN';
                turnStatus.classList.add('enemy-turn');
            }

            const display = document.getElementById('unitsDisplay');
            display.innerHTML = '';

            gameState.playerUnits.forEach(unit => {
                const card = document.createElement('div');
                card.className = 'unit-card' + (gameState.selectedUnit === unit ? ' selected' : '');

                const hpPercent = (unit.hp / unit.maxHp) * 100;
                const status = (!unit.hasMoved && !unit.hasAttacked) ? 'ready' : 'done';

                card.innerHTML = `
                    <div class="unit-header">
                        <div class="unit-name">${unit.getName()}</div>
                        <span class="status-badge ${status}">${status === 'ready' ? 'READY' : 'DONE'}</span>
                    </div>
                    <div class="hp-bar-container">
                        <div class="hp-bar ${hpPercent <= 30 ? 'low' : ''}" style="width: ${hpPercent}%"></div>
                    </div>
                    <div style="font-size: 11px; color: #3e2723; margin-top: 4px; font-weight: bold;">
                        HP: ${unit.hp}/${unit.maxHp} | KILLS: ${unit.kills}
                    </div>
                    <div class="unit-stats">
                        <div class="stat"><span class="stat-label">MOVE:</span> ${unit.moveRange}</div>
                        <div class="stat"><span class="stat-label">ATK:</span> ${unit.attackPower}</div>
                        <div class="stat"><span class="stat-label">RNG:</span> ${unit.attackRange}</div>
                        <div class="stat"><span class="stat-label">POS:</span> ${unit.x},${unit.y}</div>
                    </div>
                `;

                card.onclick = () => {
                    if (gameState.turn === 'player' && !gameState.gameOver) {
                        gameState.selectedUnit = unit;
                        selectedUnitMesh = unitMeshes.get(unit.id);
                        clearIndicators();
                        if (!unit.hasMoved) showMoveRange(unit);
                        if (!unit.hasAttacked) showAttackRange(unit);
                        updateUI();
                    }
                };

                display.appendChild(card);
            });
        }

        function endGame(playerWin) {
            gameState.gameOver = true;
            const overlay = document.getElementById('gameOverlay');
            const content = document.getElementById('gameOverContent');
            const text = document.getElementById('gameOverText');
            const score = document.getElementById('scoreDisplay');

            if (playerWin) {
                text.textContent = 'VICTORY!';
                content.classList.add('win');
                const totalKills = gameState.playerUnits.reduce((sum, u) => sum + u.kills, 0);
                const survivors = gameState.playerUnits.length;
                score.textContent = `TURNS: ${gameState.turnCount} | SURVIVORS: ${survivors} | KILLS: ${totalKills}`;
            } else {
                text.textContent = 'DEFEAT';
                content.classList.remove('win');
                score.textContent = `TURNS: ${gameState.turnCount}`;
            }

            overlay.style.display = 'flex';
        }

        function restartGame() {
            document.getElementById('gameOverlay').style.display = 'none';
            initGame();
        }
    </script>
</body>
</html>
